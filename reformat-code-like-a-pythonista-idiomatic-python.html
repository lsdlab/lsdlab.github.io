<!DOCTYPE html>
<html lang="en">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="Chen Jian">


        <title>Python专家一样编程: 地道的 Python 重新排版整理</title>

        <link href="http://blog.breakwire.me/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="BreakWire Full Atom Feed" />
        <!-- Bootstrap Core CSS -->
        <link href="/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="/theme/css/code_blocks/github.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->



        <meta name="description" content="Python专家一样编程: 地道的 Python 重新排版整理">

        <meta name="author" content="Chen Jian">

        <meta name="tags" content="reformat">

	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="BreakWire">

	<meta property="og:type" content="article">
            <meta property="article:author" content="Chen Jian" >
	<meta property="og:url" content="/reformat-code-like-a-pythonista-idiomatic-python.html">
	<meta property="og:title" content="Python专家一样编程: 地道的 Python 重新排版整理">
	<meta property="article:published_time" content="2015-07-07 14:48:37+08:00">
            <meta property="og:description" content="Python专家一样编程: 地道的 Python 重新排版整理">

            <meta property="og:image" content="//images/new-header.jpg">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">BreakWire</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">

                            <li><a href="/pages/about.html">About</a></li>
                            <li><a href="/pages/project-x.html">Project X</a></li>
                            <li><a href="/pages/resume.html">Resume</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('/images/new-header.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Python专家一样编程: 地道的 Python 重新排版整理</h1>
                        <span class="meta">Posted by
                                <a href="/author/chen-jian.html">Chen Jian</a>
                             on Tue 07 July 2015
                        </span>
                            <span class="meta">Updated on Tue 07 July 2015</span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p><a href="http://www.ch-linghu.me/article/idiomatic/handout_cn.html">Python专家一样编程: 地道的 Python</a> 重新排版整理，这个小册子虽然很老了，但里面的内容都很好，值得反复阅读。</p>
<h1>像 Python专家⼀样编程: 地道的 Python</h1>
<p>David Goodger
<a href="goodger@ python.org">goodger@python.org</a>
<a href="http://python.net/~goodger">http://python.net/~goodger</a></p>
<p>翻译: 令狐⾍虫 <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#99;&#104;&#46;&#108;&#105;&#110;&#103;&#104;&#117;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#99;&#104;&#46;&#108;&#105;&#110;&#103;&#104;&#117;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a></p>
<p>本文原文：<a href="http:// python.net/~goodger/projects/pycon/2007/idiomatic/handout.html">http:// python.net/~goodger/projects/pycon/2007/idiomatic/handout.html</a></p>
<p>在这个交互教程中,我们会探讨很多基本 Python 惯用法及其深层技术, 让你⽴即拥有⼀些有用的
⼯具。
本演⽰有 3 个版本: <a href="http://www.ch-linghu.me/article/idiomatic/presentation_cn.html">S5 幻灯⽚</a> <a href="http://www.ch-linghu.me/article/idiomatic/handout_cn.html">HTML 页⾯</a> <a href="http://www.ch-linghu.me/article/idiomatic/presentation_cn.txt">reStructuredText 源代码</a></p>
<p>©2006-2008, licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution/Share-Alike (BY-SA) license</a>.</p>
<p>本⼈简历【译注:指作者本人】: 我是</p>
<ul>
<li>蒙特利尔⼈,</li>
<li>两个优秀孩子的⽗亲,⼀个特别⼥人的丈夫,</li>
<li>全职 Python 程序员,</li>
<li><a href="http://docutils.sourceforge.net/">Docutils</a> 项⽬和 <a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> 的作者,</li>
<li>Python 改善建议(即 PEPs)的编辑,</li>
<li>PyCon 2007 组织者, PyCon 2008 主席,</li>
<li>Python 软件基⾦会成员,</li>
<li>基⾦会过去一年的董事及秘书。
在 PyCon 2006 我演⽰⼀个教程(名字叫⽂本及数据处理 (Text &amp; Data Processing)) 时,对于我使用的⼀些技术和我所认为的 ⼀些常识所得到的反应,我感到十分惊讶。这些有经验的  Python 程序员不假思索在使⽤的工具,很多与会者根本就不知道。
你们中的很多⼈应该之前已经了解了这些技术和惯⽤用法中的⼀部分。希望你们可以学到⼀些以前不知道的技术,或者在已经知道的那部分里学到些新东西。</li>
</ul>
<h2>目录</h2>
<!-- MarkdownTOC -->

<ul>
<li>Python之禅 (1)</li>
<li>Python之禅 (2)</li>
<li>代码风格：可读性至上</li>
<li>PEP 8: Style Guide for Python Code</li>
<li>空格 1</li>
<li>空格 2</li>
<li>命名</li>
<li>长代码行 &amp; 续行</li>
<li>长字符串</li>
<li>复合语句</li>
<li>Docstrings 和注释</li>
<li>实用性大于纯粹性</li>
<li>值交换</li>
<li>关于 tuple 的更多</li>
<li>交互模式下的 "_"</li>
<li>通过子字符串构建字符串</li>
<li>构建字符串, 变化 1</li>
<li>构建字符串, 变化 2</li>
<li>可能的话就用 <code>in</code> (1)</li>
<li>可能的话就用 <code>in</code> (2)</li>
<li>字典的 <code>get</code> 方法</li>
<li>字典的 <code>setdefault</code> 方法 (1)</li>
<li>字典的 <code>setdefault</code> 方法 (2)</li>
<li><code>defaultdict</code></li>
<li>构建和拆分字典</li>
<li>真值测试</li>
<li>真值</li>
<li>索引和项 (1)</li>
<li>索引和项 (2): enumerate</li>
<li>其它语言拥有「变量」</li>
<li>Python拥有「名称」</li>
<li>参数默认值</li>
<li>% 字符串格式化</li>
<li>高级 % 字符串格式化</li>
<li>高级 % 字符串格式化</li>
<li>列表推导</li>
<li>生成器表达式(1)</li>
<li>生成器表达式 (2)</li>
<li>排序</li>
<li>使用 DSU 进行排序 *</li>
<li>按键值排序</li>
<li>生成器</li>
<li>生成器举例</li>
<li>从文本/数据文件中按行读取</li>
<li>EAFP vs. LBYL</li>
<li>EAFP风格的 try/except 举例</li>
<li>导入</li>
<li>模块和脚本</li>
<li>模块结构</li>
<li>命令行处理</li>
<li>包</li>
<li>简单好过复杂</li>
<li>不要重新发明轮子</li>
<li>参考文献</li>
</ul>
<!-- /MarkdownTOC -->

<h2>Python之禅 (1)</h2>
<p>这是 Python的指导性原则，但其解释是开放性的。想要正确解释它们， 需要点儿幽默感。</p>
<p>如果你正在用一门以小品喜剧剧团命名的编程语言，你最好有点儿幽默感。</p>
<div class="highlight"><pre><span></span><span class="n">Beautiful</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">ugly</span><span class="o">.</span>
<span class="n">Explicit</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">implicit</span><span class="o">.</span>
<span class="n">Simple</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="nb">complex</span><span class="o">.</span>
<span class="n">Complex</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">complicated</span><span class="o">.</span>
<span class="n">Flat</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">nested</span><span class="o">.</span>
<span class="n">Sparse</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">dense</span><span class="o">.</span>
<span class="n">Readability</span> <span class="n">counts</span><span class="o">.</span>
<span class="n">Special</span> <span class="n">cases</span> <span class="n">aren</span><span class="s1">&#39;t special enough to break the rules.</span>
<span class="n">Although</span> <span class="n">practicality</span> <span class="n">beats</span> <span class="n">purity</span><span class="o">.</span>
<span class="n">Errors</span> <span class="n">should</span> <span class="n">never</span> <span class="k">pass</span> <span class="n">silently</span><span class="o">.</span>
<span class="n">Unless</span> <span class="n">explicitly</span> <span class="n">silenced</span><span class="o">.</span>

   <span class="o">...</span>
</pre></div>


<h2>Python之禅 (2)</h2>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="n">the</span> <span class="n">face</span> <span class="n">of</span> <span class="n">ambiguity</span><span class="p">,</span> <span class="n">refuse</span> <span class="n">the</span> <span class="n">temptation</span> <span class="n">to</span> <span class="n">guess</span><span class="o">.</span>
<span class="n">There</span> <span class="n">should</span> <span class="n">be</span> <span class="n">one</span><span class="err">—</span><span class="ow">and</span> <span class="n">preferably</span> <span class="n">only</span> <span class="n">one</span><span class="err">—</span><span class="n">obvious</span> <span class="n">way</span> <span class="n">to</span> <span class="n">do</span> <span class="n">it</span><span class="o">.</span>
<span class="n">Although</span> <span class="n">that</span> <span class="n">way</span> <span class="n">may</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">obvious</span> <span class="n">at</span> <span class="n">first</span> <span class="n">unless</span> <span class="n">you</span><span class="s1">&#39;re Dutch.</span>
<span class="n">Now</span> <span class="ow">is</span> <span class="n">better</span> <span class="n">than</span> <span class="n">never</span><span class="o">.</span>
<span class="n">Although</span> <span class="n">never</span> <span class="ow">is</span> <span class="n">often</span> <span class="n">better</span> <span class="n">than</span> <span class="n">right</span> <span class="n">now</span><span class="o">.</span>
<span class="n">If</span> <span class="n">the</span> <span class="n">implementation</span> <span class="ow">is</span> <span class="n">hard</span> <span class="n">to</span> <span class="n">explain</span><span class="p">,</span> <span class="n">it</span><span class="s1">&#39;s a bad idea.</span>
<span class="n">If</span> <span class="n">the</span> <span class="n">implementation</span> <span class="ow">is</span> <span class="n">easy</span> <span class="n">to</span> <span class="n">explain</span><span class="p">,</span> <span class="n">it</span> <span class="n">may</span> <span class="n">be</span> <span class="n">a</span> <span class="n">good</span> <span class="n">idea</span><span class="o">.</span>
<span class="n">Namespaces</span> <span class="n">are</span> <span class="n">one</span> <span class="n">honking</span> <span class="n">great</span> <span class="n">idea</span><span class="err">—</span><span class="n">let</span><span class="s1">&#39;s do more of those!</span>
<span class="err">—</span><span class="n">Tim</span> <span class="n">Peters</span>
</pre></div>


<p>这首特别的「诗」以某种玩笑开头，不过它确实揭示了很多  python 背后哲学的真相。 「 Python 之禅」已经正式进入了 PEP 20，它的摘要里说：</p>
<blockquote>
<p>元老级  Python 先锋 Tim Peters 将  Python 设计的 BDFL 指导性原则缩减成 20 条格言， 只有其中19条被写了下来。
— <a href="http://www. python.org/dev/peps/pep-0020/">http://www. python.org/dev/peps/pep-0020/</a></p>
</blockquote>
<p>你可以想想你是一个「 Python 先锋」还是一个「 Python 专家」。这两个术语有些不一样的内涵。</p>
<p>每当心存疑虑时:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">this</span>
</pre></div>


<p>试试在 python交互环境中输入:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">this</span>
</pre></div>


<p>这是另一个彩蛋:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">braces</span>
<span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">SyntaxError</span><span class="p">:</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">chance</span>
</pre></div>


<p>【译注：上面这段意思是想在特性中引入大括号，会出来一个语法异常：没机会了。 其内涵不用解释了吧】</p>
<p>真是一帮子喜剧演员！ :-)</p>
<h2>代码风格：可读性至上</h2>
<blockquote>
<p>程序是写来给人读的，只是偶尔让机器去执行。--Abelson &amp; Sussman, 计算机程序的构造与解释</p>
</blockquote>
<p>尽量让你的程序一目了然，易于阅读。</p>
<h2>PEP 8: Style Guide for Python Code</h2>
<p>Worthwhile reading:</p>
<blockquote>
<p><a href="http://www. python.org/dev/peps/pep-0008/">http://www. python.org/dev/peps/pep-0008/</a></p>
</blockquote>
<p>PEP =  python Enhancement Proposal</p>
<p>PEP是一种设计文档，用于向 python社区提供信息，或者是用来描述  Python 语言或其处理或其环境的新特性。</p>
<p>python社区对于源代码看起来应该怎么样有自己的标准，规范在 PEP 8 中。 这个标准不同于其它社区，比如 C、C++、C#、Java、VisualBasic，等等。</p>
<p>由于缩进和空格对于  Python 如此重要， Python 代码的风格指南已经基本上算是标准了。跟着指南走才是聪明的做法！大多数的开源项目和内部项目(希望如此) 非常接近的遵守风格指南。</p>
<h2>空格 1</h2>
<ul>
<li>每个缩进层次使用 4 个空格.</li>
<li>不要使用硬 tab【译注：即 <code>'\t'</code> 字符】.</li>
<li>绝对不要混用 tab 和空格.</li>
<li>这正是 IDLE 和 Emacs 的  Python 模式所支持的。其它的编辑器也应该提供这样的支持。</li>
<li>函数和函数之间空一行.</li>
<li>类和类之间空两行.</li>
</ul>
<h2>空格 2</h2>
<ul>
<li>在 dict、list、tuple 和参数列表的「,」后面，dict 的「:」后面加一个空格， 但前面不要加</li>
<li>在赋值符和关系运算符的前后加空格(参数列表里的不用)</li>
<li>紧邻括号的内部，也就是参数列表的最前面，不加空格</li>
<li>紧邻 docstrings 的内部不加空格</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_squares</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a dictionary and a list...&quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
    <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">l</span>
</pre></div>


<h2>命名</h2>
<ul>
<li>函数、方法、属性用小写+下划线形式(<code>joined_lower</code>)</li>
<li>常量用小写+下划线形式(<code>joined_lower</code>)或大写+下划线形式(<code>ALL_CAPS</code>)</li>
<li>类用首字母大写形式(<code>StudlyCaps</code>)</li>
<li>驼峰命名法(<code>camelCase</code>)仅仅用于符合事先存在的约定</li>
<li>属性: 接口(公开属性) <code>interface</code> , 内部属性 <code>_internal</code> , 私有属性 <code>__private</code>
但是尽量避免使用私用属性 <code>__private</code> 的形式。我从来没用过它。 相信我。如果你用它，你以后一定会后悔的。</li>
</ul>
<p>解释：
来自 C++/Java 背景的人特别容易过度使用/错误使用这个「特性」。但私有命名 <code>__private</code> 并不像 Java 或 C++ 里那样工作。它们只是触发了一个 命名混淆其目的是防止在子类中发生命名空间的冲突： <code>MyClass.__private</code> 会变成 <code>MyClass._MyClass__private</code> 。（注意，当基类和子类名字相同时，这种方法 会失效。比如，子类在另外一个模块的时候。）在类的外部存取一个私有属性是 完全可能的，只是不太方便和靠谱（它增加了对基类名字的精确依赖）。
问题在于，一个类的作者会合理的认为「这个属性/方法名字应该是私有的， 只能被这个类定义本身存取」然后使用了私有属性 <code>__private</code> 的约定。 但是后来，使用该类派生子类的用户会很合理的需要存取这个名字。所以 要么去改父类(一般很难甚至不可能)，要么就在子类里用手工混淆的名字(难看并且 不靠谱)。
在  python 里有一个概念：「在这里我们都是成年人」。如果你使用了私有属性 形式，你在保护谁的属性？对于子类来说，更可取的方法是正确的使用 来自父类的属性，父类把它自身的属性文档写正确才是可取之道。
更好的方法是使用单下划线约定 <code>_internal</code> 表示内部属性。 这完全不会触发命名混淆，它只是在告诉别人「小心这个，这是一个内部实现细节。 如果你没有完全理解它，不要碰它。当然，这纯粹只是一个约定而已。
关于这个问题，这里有一些很好的解释：</p>
<ul>
<li><a href="http://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private">http://stackoverflow.com/questions/70528/why-are-pythons-private-methods-not-actually-private</a></li>
<li><a href="http://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes">http://stackoverflow.com/questions/1641219/does-python-have-private-variables-in-classes</a></li>
</ul>
<h2>长代码行 &amp; 续行</h2>
<p>保持每行长度不超过80字符。</p>
<p>在括号/方括号/大括号里使用隐式续行:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">,</span> <span class="n">third</span><span class="p">,</span>
            <span class="n">fourth</span><span class="p">,</span> <span class="n">fifth</span><span class="p">,</span> <span class="n">sixth</span><span class="p">):</span>
<span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">second</span> <span class="o">+</span> <span class="n">third</span>
         <span class="o">+</span> <span class="n">fourth</span> <span class="o">+</span> <span class="n">fifth</span> <span class="o">+</span> <span class="n">sixth</span><span class="p">)</span>
</pre></div>


<p>在最后加上反斜杠表示显式续行:</p>
<div class="highlight"><pre><span></span><span class="n">VeryLong</span><span class="o">.</span><span class="n">left_hand_side</span> \
    <span class="o">=</span> <span class="n">even_longer</span><span class="o">.</span><span class="n">right_hand_side</span><span class="p">()</span>
</pre></div>


<p>反斜杠是脆弱的，它必须是一行的最后一个字符。如果你在反斜杠后面加上一个空格， 它就不再工作了。另外，它也是丑陋的。</p>
<h2>长字符串</h2>
<p>相邻的字符串文本会被语法分析器自动连接：</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s1">&#39;o&#39;</span> <span class="s1">&#39;n&#39;</span> <span class="s2">&quot;e&quot;</span>
<span class="n">one</span>
</pre></div>


<p>文本之间的空格不是必需的，但加空格可以提高可读性。 任何形式的引号都可以使用:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="s1">&#39;t&#39;</span> <span class="s1">r&#39;\/\/&#39;</span> <span class="s2">&quot;&quot;&quot;o&quot;&quot;&quot;</span>
<span class="n">t</span>\<span class="o">/</span>\<span class="o">/</span>
</pre></div>


<p>字符串加一个「r」前缀表示「原生」字符串。反斜杠在原生字符串中不再解释为脱字符。 这在写正则表达式和Windows文件系统路径时很有帮助。</p>
<p>注意，字符串变量不会被连接：</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s1">&#39;three&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;four&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span>
       <span class="n">a</span> <span class="n">b</span>

<span class="ne">SyntaxError</span><span class="p">:</span> <span class="n">invalid</span> <span class="n">syntax</span>
</pre></div>


<p>那是因为这种自动连接是  Python 语法分析器/编译器的特性，而不是解释器的。 在运行时连接字符串，你必须使用「+」操作符。</p>
<div class="highlight"><pre><span></span><span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Long strings can be made up &#39;</span>
        <span class="s1">&#39;of several shorter strings.&#39;</span><span class="p">)</span>
</pre></div>


<p>括号允许隐式续行。</p>
<p>多行字符串用三引号：</p>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;Triple</span>
<span class="sd">double</span>
<span class="sd">quotes&quot;&quot;&quot;</span>
<span class="sd">&#39;&#39;&#39;\</span>
<span class="sd">Triple</span>
<span class="sd">single</span>
<span class="sd">quotes\</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>


<p>上面的最后一个例子(三单引号)，演示了如何使用反斜杠来避免换行。 它消除了额外的换行，并将文字和引号保持为漂亮的左对齐。 反斜杠必须是每行的最后一个符号。</p>
<h2>复合语句</h2>
<p>Good:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="s1">&#39;blah&#39;</span><span class="p">:</span>
  <span class="n">do_something</span><span class="p">()</span>
<span class="n">do_one</span><span class="p">()</span>
<span class="n">do_two</span><span class="p">()</span>
<span class="n">do_three</span><span class="p">()</span>
</pre></div>


<p>Bad:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">foo</span> <span class="o">==</span> <span class="s1">&#39;blah&#39;</span><span class="p">:</span> <span class="n">do_something</span><span class="p">()</span>
<span class="n">do_one</span><span class="p">();</span> <span class="n">do_two</span><span class="p">();</span> <span class="n">do_three</span><span class="p">()</span>
</pre></div>


<p>空格和缩进可以非常有效的视觉化展现程序流程。上面「Good」第二行的 缩进就告诉了读者发生了什么事，而缺乏缩进的「Bad」则让「if」语句 变得不那么明显。</p>
<p>将多条语句写成一行是重罪。在  Python 里， 可读性至上。</p>
<h2>Docstrings 和注释</h2>
<p>Docstrings = 如何使用代码</p>
<p>注释 = 为什么 (解释) 以及代码是如何工作的</p>
<p>Docstrings 解释了如何去使用代码，它是给你代码的用户看的。 Docstrings 的使用：</p>
<ul>
<li>解释函数的目的，即使对你来说这不言自明，因为它也许对以后的其它人 来说并没有那么明显。</li>
<li>描述期望接受的参数、返回值和可能产生的任何异常。</li>
<li>如果这个方法跟一个调用者有紧密的绑定，对这个调用者做一些说明。 （但是要小心这个调用者以后可能会发生变化）</li>
</ul>
<p>注释解释了为什么，是给你代码的维护者看的。 这里有一些例子，包括写给你自己的说明，比如:</p>
<div class="highlight"><pre><span></span><span class="c1"># !!! BUG: ...</span>

<span class="c1"># !!! FIX: This is a hack</span>

<span class="c1"># ??? Why is this here?</span>
</pre></div>


<p>这里的「用户」和「维护者」都包含了 你自己 ，所以，把 Docstrings 和注释写好点！</p>
<p>Docstrings 对于交互式使用(help())和自动文档工具来说很有用。</p>
<p>错误的注释和 docstrings 比没有还要更糟。所以，保持它们的更新！当你做了 变更，确保注释和docstrings 和代码保持一致，不要让它们产生矛盾。</p>
<p>这里有一个专门的关于 Docstring 的 PEP，PEP 257，"Docstring 约定"</p>
<blockquote>
<p>http://www. python.org/dev/peps/pep-0257/</p>
</blockquote>
<h2>实用性大于纯粹性</h2>
<blockquote>
<p>A foolish consistency is the hobgoblin of little minds.
【译注：这句话里的 consisitency 带双关性，原意和这里的意思不一样，不好译，就不译了】
—Ralph Waldo Emerson</p>
</blockquote>
<p>(hobgoblin: 导致迷信的恐惧的事情; 一个稻草人.)</p>
<p>永远都存在例外. PEP 8中说:</p>
<blockquote>
<p>但是最重要的一点：知道何时不一致 —— 有时风格指南无法应用。在有 疑问时，使用你的最佳判断。查看其它的例子，然后决定哪个看起来最好。 另外，别迟疑，赶快问！</p>
<p>两个打破常规的好理由：
1. 当使用规则会让代码变得更难读，甚至对以前读过使用该规则代码 的人来说也是如此时。
2. 为了跟周围同样破坏规则的代码保持一致(通常是因为历史原因)。 —— 不过，这也是一个清理垃圾的机会(在真正的 XP 风格中)。</p>
</blockquote>
<p>... 无论如何实用性不能把纯粹性打成一团肉酱！</p>
<h2>值交换</h2>
<p>在其它语言里:</p>
<div class="highlight"><pre><span></span><span class="n">temp</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">temp</span>
</pre></div>


<p>在 Python里:</p>
<div class="highlight"><pre><span></span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
</pre></div>


<p>可能你以前已经见过。但是你知道它是如何工作的吗？</p>
<ul>
<li>逗号是 tuple 构造语法</li>
<li>右边建立了一个 tuple (tuple packing).</li>
<li>左边是一个目标 tuple (tuple unpacking).</li>
</ul>
<p>右手边 <strong>解包(unpacked)</strong> 到左手边 tuple 里对应的名字</p>
<p>更多 unpacking 的例子：</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span><span class="p">[</span><span class="s1">&#39;David&#39;</span><span class="p">,</span> <span class="s1">&#39; pythonista&#39;</span><span class="p">,</span> <span class="s1">&#39;+1-514-555-1234&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">phone</span> <span class="o">=</span> <span class="n">l</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">name</span>
<span class="s1">&#39;David&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">title</span>
<span class="s1">&#39; pythonista&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">phone</span>
<span class="s1">&#39;+1-514-555-1234&#39;</span>
</pre></div>


<p>对于循环处理结构数据很有用：</p>
<p>l (L) 是我们刚刚在上面建立的 (David 的信息)。所以 people 是一个包含两个项的 list，每个项都是一个包含3个项的 list。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Guido&#39;</span><span class="p">,</span> <span class="s1">&#39;BDFL&#39;</span><span class="p">,</span> <span class="s1">&#39;unlisted&#39;</span><span class="p">]]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">phone</span><span class="p">)</span> <span class="ow">in</span> <span class="n">people</span><span class="p">:</span>
<span class="o">...</span>     <span class="k">print</span> <span class="n">name</span><span class="p">,</span> <span class="n">phone</span>
<span class="o">...</span>
<span class="n">David</span> <span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="mi">514</span><span class="o">-</span><span class="mi">555</span><span class="o">-</span><span class="mi">1234</span>
<span class="n">Guido</span> <span class="n">unlisted</span>
</pre></div>


<p><code>people</code> 中的每一项都被 unpacked 到<code>(name, title, phone)</code>这个 tuple。</p>
<p>可以任意嵌套 (只要保证左右两边的结构匹配):</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">david</span><span class="p">,</span> <span class="p">(</span><span class="n">gname</span><span class="p">,</span> <span class="n">gtitle</span><span class="p">,</span> <span class="n">gphone</span><span class="p">)</span> <span class="o">=</span> <span class="n">people</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">gname</span>
<span class="s1">&#39;Guido&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">gtitle</span>
<span class="s1">&#39;BDFL&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">gphone</span>
<span class="s1">&#39;unlisted&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">david</span>
<span class="p">[</span><span class="s1">&#39;David&#39;</span><span class="p">,</span> <span class="s1">&#39; pythonista&#39;</span><span class="p">,</span> <span class="s1">&#39;+1-514-555-1234&#39;</span><span class="p">]</span>
</pre></div>


<h2>关于 tuple 的更多</h2>
<p>我们注意到，逗号是 tuple 的构造项，而不是括号。例如：</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</pre></div>


<p>为了清晰起见， Python 解释器会显示括号。我也同样推荐你使用括号：</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</pre></div>


<p>不要忘记逗号！</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>


<p>在单元素 tuple中，尾部的逗号是必需的；在两个及以上元素的 tuple 中， 尾部的逗号是可选的。0 元素的 tuple，也就是空 tuple，用一对括号来作为简化语法。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="p">()</span>
<span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">tuple</span><span class="p">()</span>
<span class="p">()</span>
</pre></div>


<p>一个常见的错误就是在不需要 tuple 的地方留了一个逗号 【译注：于是变成了一个 tuple】 这会很轻易的让你的代码发生错误。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">value</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
</pre></div>


<p>所以如果你在意想不到的地方看到了一个 tuple，检查逗号！</p>
<h2>交互模式下的 "_"</h2>
<p>这真的是一个非常有用的特性。奇怪的是很少有人知道。</p>
<p>在交互式解释器里，当你对一个表达式求值或调用了一个函数，其结果会 存入一个临时名称， <code>_</code> (一个下划线):</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">_</span>
<span class="mi">2</span>
</pre></div>


<p><code>_</code> 保存最后一个打印出来的结果</p>
<p>当结果是 <code>None</code> 的时候，什么也没有打印，所以 <code>_</code> 不会发生变化。 这很方便！</p>
<p>这只在交互式解释器里有用，在 module 里没用。</p>
<p>当你交互式的解决一个问题，然后你想保存上一步的结果时，这个功能尤其方便。</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">math</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span>
<span class="mf">1.0471975511965976</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">_</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
<span class="mf">0.50000000000000011</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">_</span>
<span class="mf">0.50000000000000011</span>
</pre></div>


<h2>通过子字符串构建字符串</h2>
<p>从一个字符串列表开始：</p>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>
</pre></div>


<p>我们想把全部这些字符串合并成一个大字符串。尤其是子字符串数量很大的时候...
别这样做:</p>
<div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">s</span>
</pre></div>


<p>这么做非常的低效。</p>
<p>这是一个典型的恐怖内存占用和恐怖性能的范例。「合并结果」在 每一个中间步骤都会计算、存储然后被抛弃。</p>
<p>相反的，你应该这么做:</p>
<div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
</pre></div>


<p>字符串方法 <code>join()</code> 会一次性做完全部的复制动作。</p>
<p>当你只是处理几十甚至几百个字符串时，它们的差别不会很大。 但是要养成使用高效字符串构建方法的习惯， 因为当你处理上千个字符串，或者是在循环中进行处理， 它们确实有差别。</p>
<h2>构建字符串, 变化 1</h2>
<p>这里有一些使用字符串方法 <code>join()</code> 的技巧。
如果你想在每一个子字符串之间插入一个空格:</p>
<div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
</pre></div>


<p>或者是逗号加空格:</p>
<div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
</pre></div>


<p>这是一种常见情况:</p>
<div class="highlight"><pre><span></span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow&#39;</span><span class="p">]</span>
<span class="k">print</span> <span class="s1">&#39;Choose&#39;</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> \
     <span class="s1">&#39;or&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>


<p>为了生成语法更漂亮的句子，我们想在除了最后一对数据之外的全部数据对之间插入一个逗号， 最后一对数据之间我们放一个单词「or」。【译注：当然这符合的是英文语法。 中文可能更常见的是顿号和「和」】「直到 -1元素的切片」 (<code>[:-1]</code>) 给出了除最后数据之外的全部数据，它们之间用「逗号加空格」分隔合并。</p>
<p>当然，这个代码在边际条件下无法运行，当 list 的长度为 0 或 1 时。</p>
<p>输出结果:</p>
<div class="highlight"><pre><span></span><span class="n">Choose</span> <span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">green</span> <span class="ow">or</span> <span class="n">yellow</span>
</pre></div>


<h2>构建字符串, 变化 2</h2>
<p>如果你需要应用一个函数来产生子字符串:</p>
<div class="highlight"><pre><span></span>    <span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>
</pre></div>


<p>这涉及生成表达式(generator expression) ，我们随后会讨论。
如果你要增量计算子字符串的话，先将它们累积到一个列表中:</p>
<div class="highlight"><pre><span></span><span class="n">items</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">...</span>
<span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>  <span class="c1"># many times</span>
<span class="o">...</span>
<span class="c1"># items is now complete</span>
<span class="n">result</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>
</pre></div>


<p>我们先把需要处理的部分累积到一个列表中， 然后我们就可以应用字符串方法 join ，高效处理。</p>
<h2>可能的话就用 <code>in</code> (1)</h2>
<p>Good:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">key</span>
</pre></div>


<ul>
<li>in 通常情况下都会比较快。</li>
<li>该模式也可以用于随机存取容器（比如 lists、tuples 和 sets）中的项</li>
<li>in 也是一个操作符 (我们马上就会看到).</li>
</ul>
<p>Bad:</p>
<div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">print</span> <span class="n">key</span>
</pre></div>


<p>这会限制为只能操作有 keys() 方法的对象。</p>
<h2>可能的话就用 <code>in</code> (2)</h2>
<p>但当我们修改一个字典时， <code>.keys()</code> 是必需的:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="n">d</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>


<p><code>d.keys()</code> 创建了一个包含字典键值的静态链表。 如果不这样做, 你会得到一个异常 "RuntimeError: dictionary changed size during iteration".
从一致性来考虑, 使用 <code>key in dict</code>, 而不是 <code>dict.has_key()</code>:</p>
<div class="highlight"><pre><span></span><span class="c1"># do this:</span>
<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="o">...</span><span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="c1"># not this:</span>
<span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="o">...</span><span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</pre></div>


<p>在这种用法里， <code>in</code> 是一个操作符.</p>
<h2>字典的 <code>get</code> 方法</h2>
<p>We often have to initialize dictionary entries before use: 通常我们需要在使用之前初始化一个字典。</p>
<p>这是比较幼稚的做法:</p>
<div class="highlight"><pre><span></span><span class="n">navs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">equity</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
<span class="k">if</span> <span class="n">portfolio</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">navs</span><span class="p">:</span>
    <span class="n">navs</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">navs</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span> <span class="o">+=</span> <span class="n">position</span> <span class="o">*</span> <span class="n">prices</span><span class="p">[</span><span class="n">equity</span><span class="p">]</span>
</pre></div>


<p><code>dict.get(key, default)</code> 移除了对条件判断的需要:</p>
<div class="highlight"><pre><span></span><span class="n">navs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">equity</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">navs</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">navs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                      <span class="o">+</span> <span class="n">position</span> <span class="o">*</span> <span class="n">prices</span><span class="p">[</span><span class="n">equity</span><span class="p">])</span>
</pre></div>


<p>直观多了。</p>
<h2>字典的 <code>setdefault</code> 方法 (1)</h2>
<p>现在我们要用初始化一个可变的字典的值。每个字典值是一个 list。 这是比较幼稚的做法：</p>
<p>Initializing mutable dictionary values:</p>
<div class="highlight"><pre><span></span><span class="n">equities</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">equity</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">portfolio</span> <span class="ow">in</span> <span class="n">equities</span><span class="p">:</span>
        <span class="n">equities</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">equity</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">equities</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">equity</span><span class="p">]</span>
</pre></div>


<p><code>dict.setdefault(key, default)</code> 可以以高得多的效率完成同样的工作:</p>
<div class="highlight"><pre><span></span><span class="n">equities</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">equity</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">equities</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">equity</span><span class="p">)</span>
</pre></div>


<p><code>dict.setdefault()</code> 等价于 <code>get, or set &amp; get</code>. 也就是 "如果有必要的话，<code>set</code>，然后 <code>get</code>. 它对于字典键值计算代价昂贵或很长难以输入的情况特别有价值。</p>
<p><code>dict.setdefault()</code> 的唯一问题是默认值总是会被计算，无论需要与否。 这会在默认值计算代价昂贵的时候带来一些麻烦。</p>
<p>如果默认值确实计算代价昂贵，你可能希望使用 <code>defaultdict</code> 类， 我们下面很快就会涉及。</p>
<h2>字典的 <code>setdefault</code> 方法 (2)</h2>
<p>现在我们来看看字典方法 <code>setdefault</code> 也可以用在独立语句中。</p>
<p><code>setdefault</code> 同样可以用于独立语句中:</p>
<div class="highlight"><pre><span></span><span class="n">navs</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">equity</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">navs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">navs</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span> <span class="o">+=</span> <span class="n">position</span> <span class="o">*</span> <span class="n">prices</span><span class="p">[</span><span class="n">equity</span><span class="p">]</span>
</pre></div>


<p>The <code>setdefault</code> dictionary method returns the default value, but we ignore it here. We're taking advantage of <code>setdefault</code>'s side effect, that it sets the dictionary value only if there is no value already. 字典方法 <code>setdefault</code> 返回一个默认值，但是在这里我们忽略了它。 我们用到了 <code>setdefault</code> 的边际效应带来的优点， 它仅仅在字典对应键值没有值的情况下才会去设置值。</p>
<h2><code>defaultdict</code></h2>
<p>python 2.5 新增.</p>
<p><code>defaultdict</code> 在  python 2.5中新增, 是 <code>collections</code> 模块中的一员. <code>defaultdict</code> 跟一个普通的字典完全一样, 除了两点:</p>
<ul>
<li>它在构造时带一个额外的第一参数: 一个默认工厂函数。并且</li>
<li>当字典键值第一次被操作时，默认工厂函数被调用，产生的结果用于初始化该键值。</li>
</ul>
<p>有两种方法可以得到一个 <code>defaultdict</code>:</p>
<p>导入 <code>collections</code> 模块并通过模块引用</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>


<p>或直接导入 <code>defaultdict</code> 名称:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>


<p>这是前面用过的一个例子，每一个字典值都必须被初始化成一个空 list， 现在用 <code>defaultdict</code> 改写它：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="err">å</span>
<span class="n">equities</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">equity</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">equities</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">equity</span><span class="p">)</span>
</pre></div>


<p>根本没有做什么探索工作。在这个例子里，默认工厂函数是 <code>list</code> ， 返回一个空 list。</p>
<p>这个例子演示了如何得到一个初始值为 0 的字典：使用 <code>int</code> 作为默认工厂函数:</p>
<div class="highlight"><pre><span></span><span class="n">navs</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">portfolio</span><span class="p">,</span> <span class="n">equity</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
    <span class="n">navs</span><span class="p">[</span><span class="n">portfolio</span><span class="p">]</span> <span class="o">+=</span> <span class="n">position</span> <span class="o">*</span> <span class="n">prices</span><span class="p">[</span><span class="n">equity</span><span class="p">]</span>
</pre></div>


<p>不过你还是得小心使用 <code>defaultdict</code> 。从一个正确初始化的 defaultdict 实例里你永远得不到 KeyError 异常。如果你需要检查特定键值存在与否， 必须使用「key in dict」条件判断。</p>
<h2>构建和拆分字典</h2>
<p>下面是一个很有用的技巧，如何通过两个 list (或其它序列)构建一个字典: 一个 list 是键，一个 list 是值。</p>
<div class="highlight"><pre><span></span><span class="n">given</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;Eric&#39;</span><span class="p">,</span> <span class="s1">&#39;Terry&#39;</span><span class="p">,</span> <span class="s1">&#39;Michael&#39;</span><span class="p">]</span>
<span class="n">family</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Cleese&#39;</span><span class="p">,</span> <span class="s1">&#39;Idle&#39;</span><span class="p">,</span> <span class="s1">&#39;Gilliam&#39;</span><span class="p">,</span> <span class="s1">&#39;Palin&#39;</span><span class="p">]</span>
 <span class="n">pythons</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">given</span><span class="p">,</span> <span class="n">family</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span> <span class="n">pythons</span><span class="p">)</span>
<span class="p">{</span><span class="s1">&#39;John&#39;</span><span class="p">:</span> <span class="s1">&#39;Cleese&#39;</span><span class="p">,</span>
 <span class="s1">&#39;Michael&#39;</span><span class="p">:</span> <span class="s1">&#39;Palin&#39;</span><span class="p">,</span>
 <span class="s1">&#39;Eric&#39;</span><span class="p">:</span> <span class="s1">&#39;Idle&#39;</span><span class="p">,</span>
 <span class="s1">&#39;Terry&#39;</span><span class="p">:</span> <span class="s1">&#39;Gilliam&#39;</span><span class="p">}</span>
</pre></div>


<p>反过来，当然，也很直观:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span>  <span class="n">pythons</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="p">[</span><span class="s1">&#39;John&#39;</span><span class="p">,</span> <span class="s1">&#39;Michael&#39;</span><span class="p">,</span> <span class="s1">&#39;Eric&#39;</span><span class="p">,</span> <span class="s1">&#39;Terry&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span>  <span class="n">pythons</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="p">[</span><span class="s1">&#39;Cleese&#39;</span><span class="p">,</span> <span class="s1">&#39;Palin&#39;</span><span class="p">,</span> <span class="s1">&#39;Idle&#39;</span><span class="p">,</span> <span class="s1">&#39;Gilliam&#39;</span><span class="p">]</span>
</pre></div>


<p>注意结果中 .keys() 和 .values() 的顺序和构建字典时的项顺序不同。 进去的顺序跟出来的顺序不一样。这是因为字典本质上是非顺序的。然而， 这个顺序可以保证一致性（换句话说，键的顺序和值的顺序是一一对应的）， 只要两次调用之间字典没有发生改变.</p>
<h2>真值测试</h2>
<div class="highlight"><pre><span></span><span class="c1"># 这样做:         # 不要这样做:</span>
<span class="k">if</span> <span class="n">x</span><span class="p">:</span>            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">pass</span>             <span class="k">pass</span>
</pre></div>


<p>这种方法优雅且高效的利用了  python 对象内置的真值。</p>
<p>测试一个列表:</p>
<div class="highlight"><pre><span></span><span class="c1"># 这样做:         # 不要这样做:</span>
<span class="k">if</span> <span class="n">items</span><span class="p">:</span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">pass</span>             <span class="k">pass</span>

                 <span class="c1"># 千万不要这样做:</span>
                 <span class="k">if</span> <span class="n">item</span>
                     <span class="k">pass</span>
</pre></div>


<h2>真值</h2>
<p><code>True</code> 和 <code>False</code> 是两个 <code>bool</code> 类型的内置实例，布尔值。 跟 <code>None</code> 一样，它们各只会有一个实例存在。</p>
<table>
<thead>
<tr>
<th>False</th>
<th>True</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>False</code> (== 0)</td>
<td><code>True</code> (== 1)</td>
<td></td>
</tr>
<tr>
<td><code>""</code> (空字符串)   除了 <code>""</code> 之外的所有字符串(<code>" "</code>, <code>"anything"</code>)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>0</code>, <code>0.0</code></td>
<td>除了 0 之外的所有数(1, 0.1, -1, 3.14)</td>
<td></td>
</tr>
<tr>
<td><code>[]</code>, <code>()</code>, <code>{}</code>, <code>set()</code></td>
<td>任何非空容器 (<code>[0]</code>, <code>(None,)</code>, `[''])</td>
<td></td>
</tr>
<tr>
<td><code>None</code></td>
<td>几乎所有未被显式置为False 的对象。</td>
<td></td>
</tr>
</tbody>
</table>
<p>对象真值示例：</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">C</span><span class="p">:</span>
<span class="o">...</span>  <span class="k">pass</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">o</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">bool</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="bp">True</span>
</pre></div>


<p>(Examples: execute <a href="http://www.ch-linghu.me/article/idiomatic/truth.py">truth.py</a>.)</p>
<p>想要控制一个用户定义类实例的真值，使用特殊方法 <code>__nonzero__</code> 或 <code>__len__</code> 。如果你的类是一个有长度的容器:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Return my length.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>


<p>如果你的类不是一个容器，使用 <code>__nonzero__</code>:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return my truth value (True or False).&quot;&quot;&quot;</span>
        <span class="c1"># This could be arbitrarily complex:</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>


<p>在  Python 3.0 中，为了与 bool 内置类型保持一致性， <code>__nonzero__</code> 被改名成了 <code>__bool__</code> 。为了保持兼容性，在类中增加如下定义:</p>
<div class="highlight"><pre><span></span><span class="n">__bool__</span> <span class="o">=</span> <span class="n">__nonzero__</span>
</pre></div>


<h2>索引和项 (1)</h2>
<p>当你需要一个单词列表的时候，有种可爱的方法可以节省你的打字时间:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="s1">&#39;zero one two three&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">items</span>
<span class="p">[</span><span class="s1">&#39;zero&#39;</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">]</span>
</pre></div>


<p>假设我们需要遍历这些项，并且我们同时需要项和项的索引值:</p>
<div class="highlight"><pre><span></span>                      <span class="o">-</span> <span class="err">或</span> <span class="o">-</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)):</span>
    <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span>                   <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>


<h2>索引和项 (2): enumerate</h2>
<p>函数 <code>enumerate</code> 接受一个 list，并返回 (索引值, 项) 对:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
<span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">)]</span>
</pre></div>


<p>输出结果时，我们得用一个 <code>list</code> 进行一下包装，因为 <code>enumerate</code> 是一个惰性函数: 它仅仅在需要时才一次产生一项，一个索引项对。 for 循环就是一个一次需要一个结果的所在。 <code>enumerate</code> 是生成器(generator) 的一个例子，我们将会在以后详细的讲解生成器。 <code>print</code> 不是一次拿一个结果 —— 我们需要整个结果，所以我们在打印时， 必须显式的将一个生成器转换为一个 list。</p>
<p>我们的循环变得简单多了:</p>
<div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span>

<span class="c1"># 对比:                     # 对比:</span>
<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>         <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="n">items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">print</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span>
    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>


<p><code>enumerate</code> 版本比左边的版本短得多也简单得多，而且也更加易读易理解。</p>
<p>下面这个例子展现 <code>enumerate</code> 函数实际上是如何返回一个迭代器(iterator)的 (生成器就是一种迭代器):</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
<span class="o">&lt;</span><span class="nb">enumerate</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x011EA1C0</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;zero&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
    <span class="n">File</span> <span class="s2">&quot;&lt;stdin&gt;&quot;</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="err">?</span>
<span class="ne">StopIteration</span>
</pre></div>


<h2>其它语言拥有「变量」</h2>
<p>在很多其它语言中，对一个变量赋值，就是将一个值放入一个盒子中。
<code>int a = 1;</code>
<img alt="a1box.png" src="http://www.ch-linghu.me/article/idiomatic/a1box.png" /></p>
<p>盒子「a」现在存放了一个整数1。</p>
<p>将其它值赋值给同一个变量就是替换盒子中的内容:
<code>a = 2;</code>
<img alt="a2box.png" src="http://www.ch-linghu.me/article/idiomatic/a2box.png" /></p>
<p>现在盒子「a」存放了整数2。</p>
<p>将一个变量赋值给其它变量，就是复制一个值，并将它放入新的盒子:
<code>int b = a;</code>
<img alt="b2box.png" src="http://www.ch-linghu.me/article/idiomatic/b2box.png" />    <img alt="a2box.png" src="http://www.ch-linghu.me/article/idiomatic/a2box.png" /></p>
<p>「b」是第二个盒子，存放着一个经过复制的2。盒子「a」里有一份独立的备份。</p>
<h2>Python拥有「名称」</h2>
<p>在 python中，「名字」或「标识符」就像一个打在对象上的邮件标签(也就是一个命名标签)。
<code>a = 1</code>
<img alt="a1tag.png" src="http://www.ch-linghu.me/article/idiomatic/a1tag.png" /></p>
<p>在这里，整数1对象有一个标签，上面写着「a」。</p>
<p>如果我们对「a」重新赋值，我们只是将这个标签移动到了其它对象:</p>
<p><code>a = 2</code>
<img alt="a2tag.png" src="http://www.ch-linghu.me/article/idiomatic/a2tag.png" />    <img alt="1.png" src="http://www.ch-linghu.me/article/idiomatic/1.png" /></p>
<p>现在名字「a」跟整数2对象联系在了一起。</p>
<p>原先的整数1对象不再有标签「a」了。对象本身可能还存在， 但是我们不能通过名字「a」得到它了。（当一个对象身上没有任何标签或者引用， 它会被从内存中删除。）</p>
<p>如果我们将一个名字赋值给另一个，我们只是为一个已经存在的对象挂上另一个名字的标签:</p>
<p><code>b = a</code>
<img alt="ab2tag.png" src="http://www.ch-linghu.me/article/idiomatic/ab2tag.png" /></p>
<p>名字「b」只是挂到原先「a」所指对象的第二个标签。</p>
<p>虽然我们即使在  python中通常也使用「变量」(因为这是一个常用术语)， 我们实际上指的是「名字」或「标识符」。在  python 里， 「变量」是值的命名标签，而不是一个写了名字的盒子。</p>
<p>如果你没有从本教程中得到别的什么收获， 我希望你至少能理解  python「名字」是如何工作的。 这种理解一定会成为额外的红利，帮助你避免以下情形:
➔</p>
<h2>参数默认值</h2>
<p>这是一个初学者常见的错误。甚至一些有经验的程序员， 如果他们没有理解  python「名字」，也会犯同样的错误。</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bad_append</span><span class="p">(</span><span class="n">new_item</span><span class="p">,</span> <span class="n">a_list</span><span class="o">=</span><span class="p">[]):</span>
    <span class="n">a_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_list</span>
</pre></div>


<p>问题在于 a_list 的默认值，一个空列表，是在函数定义时被求值的。 所以每次调用这个函数，我们得到的是同一个默认值。试试重复做几次:</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; print bad_append(&#39;one&#39;)
[&#39;one&#39;]
&gt;&gt;&gt; print bad_append(&#39;two&#39;)
[&#39;one&#39;, &#39;two&#39;]
</pre></div>


<p>列表是一个可变对象；我们可以改变它们的内容。 得到一个默认列表的正确方法是在运行时创建，在函数内部:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">good_append</span><span class="p">(</span><span class="n">new_item</span><span class="p">,</span> <span class="n">a_list</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a_list</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">a_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">a_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_list</span>
</pre></div>


<h2>% 字符串格式化</h2>
<p>python的 <code>%</code> 操作符很像 C 语言的 <code>sprintf</code> 函数那样运作。
就算你对 C 语言不了解，关系也不大。基本上，你给出了一个模板， 或者说是格式，以及用于插入的数据。</p>
<p>在这个例子里，模板包含了两个转换规则：「%s」表示「在这里插入一个字符串」， 「%i」表示「将一个整型数转换成一个字符串并插入到这里」。 「%s」特别有用，因为它使用了  Python 的内置 str() 函数将任何对象转换成字符串。</p>
<p>用于插入的数据必须跟模板匹配；这里我们用了两个数据，一个 tuple。</p>
<div class="highlight"><pre><span></span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;David&#39;</span>
<span class="n">messages</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">text</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Hello </span><span class="si">%s</span><span class="s1">, you have </span><span class="si">%i</span><span class="s1"> messages&#39;</span>
        <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">messages</span><span class="p">))</span>
<span class="k">print</span> <span class="n">text</span>
</pre></div>


<p>输出结果:</p>
<div class="highlight"><pre><span></span><span class="n">Hello</span> <span class="n">David</span><span class="p">,</span> <span class="n">you</span> <span class="n">have</span> <span class="mi">3</span> <span class="n">messages</span>
</pre></div>


<p>详细的讨论在  python 库参考 ，第 2.3.6.2 节， 「字符串格式化操作」 。 一定要记得去看！
如果你还没做，去  Python.org ，下载 HTML 格式的文档(zip 包或者 tar 包)， 装到自己的电脑上。没什么事比最终文档就在你手边更好的。</p>
<h2>高级 % 字符串格式化</h2>
<p>大多数人都不知道有另外一种更灵活的字符串格式化方式:
利用字典键值:</p>
<div class="highlight"><pre><span></span><span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;messages&#39;</span><span class="p">:</span> <span class="n">messages</span><span class="p">}</span>
<span class="k">print</span> <span class="p">(</span><span class="s1">&#39;Hello </span><span class="si">%(name)s</span><span class="s1">, you have </span><span class="si">%(messages)i</span><span class="s1"> &#39;</span>
       <span class="s1">&#39;messages&#39;</span> <span class="o">%</span> <span class="n">values</span><span class="p">)</span>
</pre></div>


<p>这里我们指定了插入数据的名字，这些名字可以在随后提供的字典中找到。</p>
<p>注意到什么冗余之处没有？ 名字 「name」 和 「messages」已经在本地命名空间中定义了。 我们可以利用这一点。</p>
<p>使用本地命名空间中的名字:</p>
<div class="highlight"><pre><span></span><span class="k">print</span> <span class="p">(</span><span class="s1">&#39;Hello </span><span class="si">%(name)s</span><span class="s1">, you have </span><span class="si">%(messages)i</span><span class="s1"> &#39;</span>
       <span class="s1">&#39;messages&#39;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>
</pre></div>


<p><code>locals()</code> 函数返回一个本地可用的名字的字典。</p>
<p>这非常强大。利用它，我们可以完成你想要的任何字符串格式化， 不用考虑模板的插入数据问题。</p>
<p>不过能力也会带来危险。（「能力越大，责任越大」） 如果对一个外部提供的模板字符串使用 <code>locals()</code> 形式， 你实际上将你的整个本地命名空间都暴露给了调用者。你必须对此保持警惕。</p>
<p>检查你的本地命名空间:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pprint</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
</pre></div>


<p><code>pprint</code> 是一个非常有用的模块。如果你还不知道，尝试去把玩把玩。 它会让你调试数据结构更加轻松！</p>
<h2>高级 % 字符串格式化</h2>
<p>一个对象实例属性的名字空间实际上就是一个字典， <code>self.__dict__</code> 。
使用实例名字空间中的名字:</p>
<div class="highlight"><pre><span></span><span class="k">print</span> <span class="p">(</span><span class="s2">&quot;We found </span><span class="si">%(error_count)d</span><span class="s2"> errors&quot;</span>
       <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)</span>
</pre></div>


<p>等价于，但比下面的形式更灵活:</p>
<div class="highlight"><pre><span></span><span class="k">print</span> <span class="p">(</span><span class="s2">&quot;We found </span><span class="si">%d</span><span class="s2"> errors&quot;</span>
       <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">error_count</span><span class="p">)</span>
</pre></div>


<p>注意：类属性在类的 <code>__dict__</code> 里。名字空间查找实际上是链式字典查找。</p>
<h2>列表推导</h2>
<p>列表推导 (List Comprehensions) (简写为「listcomps」) 是以下这种常见模式的语法简写:
传统方法，使用 for 和 if 语句:</p>
<div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a_list</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
</pre></div>


<p>使用列表推导:</p>
<div class="highlight"><pre><span></span><span class="n">new_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">fn</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a_list</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span>
</pre></div>


<p>从某种程度上来说，列表推导清晰、简洁。你可以在列表推导中使用多个 <code>for</code> 循环和 <code>if</code> 条件，但是如果总数超过两个或三个， 或者条件非常复杂，我还是建议使用传统的 <code>for</code> 循环。套用  python之禅 的说法，选择更易读的那个。
举个例子来说，0-9 的平方列表:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">]</span>
</pre></div>


<p>0-9 中奇数的平方列表:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">81</span><span class="p">]</span>
</pre></div>


<h2>生成器表达式(1)</h2>
<p>假设我们要求 1-100 的平方的和:
循环解法:</p>
<div class="highlight"><pre><span></span><span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">num</span> <span class="o">*</span> <span class="n">num</span>
</pre></div>


<p>通过构造适当的序列，我们可以使用 <code>sum</code> 函数更快的达到目的。</p>
<p>列表推导解法:</p>
<div class="highlight"><pre><span></span><span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">num</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">)])</span>
</pre></div>


<p>生成器表达式解法:</p>
<div class="highlight"><pre><span></span><span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span> <span class="o">*</span> <span class="n">num</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">))</span>
</pre></div>


<p>生成器表达式 (Generator expressions) (「genexps」) 跟列表推导很像， 不过列表推导是贪婪的，而生成器表达式是惰性的。列表推导一次性计算出 整个列表的全部结果，并以列表形式返回。生成器表达式只会在需要时一次计算一个数据， 以一个单独的值形式返回。这对于那种对很长的序列求解， 但计算结果只是中间步骤而并非最终结果的情况特别有用。</p>
<p>在上面的例子中，我们只关心求和的结果，我们不需要列表中每个元素平方的中间结果。 基于同样的理由，我们使用了 <code>xrange</code> ：它惰性产生结果，每次一个。</p>
<h2>生成器表达式 (2)</h2>
<p>举个例子来说，如果我们要计算数十亿整数的平方和，如果使用列表推导， 会内存溢出，但生成器表达式没有问题。不过要花些时间。</p>
<div class="highlight"><pre><span></span><span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">num</span> <span class="o">*</span> <span class="n">num</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000000000</span><span class="p">))</span>
</pre></div>


<p>语法方面的差别在于列表推导有方括号，生成器表达式没有。 有些时候生成器表达式需要用括号括住，所以你最好每次都这样做。
规则摘要:</p>
<ul>
<li>当计算结果列表是最终结果时，使用列表推导。</li>
<li>当计算结果列表仅作为中间步骤时，使用生成器表达式</li>
</ul>
<p>这是我在最近工作中见到的一个例子。
➔
我们需要为未来的合同产生一份月份数(同时以字符串形式和整型存在)到月份代码映射的字典。 这可以用一个逻辑行完成。
➔</p>
<p>完成方法如下:</p>
<ul>
<li>内置的 <code>dict()</code> 函数产生一个键/值对列表 (2个 tuple).</li>
<li>我们有一份月份代码列表(每个月份代码是一个单字母，字符串就是字母的列表)。 我们遍历这个列表获得月份代码及其索引值。</li>
<li>月份数从  1开始，但  Python 索引值从 0 开始，所以月份数等于索引值 +1。</li>
<li>我们希望同时以字符串和整型检查月份。所以我们使用 int() 和 str() 函数来做，并在此基础上进行查找。</li>
</ul>
<p>最近的例子:</p>
<div class="highlight"><pre><span></span><span class="n">month_codes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">fn</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">code</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">code</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="s1">&#39;FGHJKMNQUVXZ&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>
</pre></div>


<p><code>month_codes</code> 的结果:</p>
<div class="highlight"><pre><span></span><span class="p">{</span> <span class="mi">1</span><span class="p">:</span>  <span class="s1">&#39;F&#39;</span><span class="p">,</span>  <span class="mi">2</span><span class="p">:</span>  <span class="s1">&#39;G&#39;</span><span class="p">,</span>  <span class="mi">3</span><span class="p">:</span>  <span class="s1">&#39;H&#39;</span><span class="p">,</span>  <span class="mi">4</span><span class="p">:</span>  <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="o">...</span>
<span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>
</pre></div>


<h2>排序</h2>
<p>在  Python 里对一个 list 进行排序非常简单:</p>
<div class="highlight"><pre><span></span><span class="n">a_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</pre></div>


<p>(注意，list的排序是就地进行的：原先的 list 直接变成排序好的，而且 <code>sort</code> 方法不会返回这个list或其拷贝。)
但是当你不想以正常顺序 (比如，按第一列排序，然后按第二列，等等) 排序列表数据是应该怎么做呢？比如你想按先第二列排序，然后按第四列。</p>
<p>我们可以为内置的 <code>sort</code> 方法传入一个自定义函数:</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">custom_cmp</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">((</span><span class="n">item1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">item1</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                   <span class="p">(</span><span class="n">item2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">item2</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>

    <span class="n">a_list</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">custom_cmp</span><span class="p">)</span>
</pre></div>


<p>这行得通，不过在处理大型列表时会非常非常慢。</p>
<h2>使用 DSU 进行排序 *</h2>
<p>DSU = Decorate-Sort-Undecorate (修饰-排序-反修饰)</p>
<ul>
<li>注意: DSU现在一般用不到了。新的方法见下一节， <a href="http://www.ch-linghu.me/article/idiomatic/handout_cn.html#id29">按键值排序</a></li>
</ul>
<p>我们创建一个会自然排序的辅助列表，而不是创建一个自定义比较函数</p>
<div class="highlight"><pre><span></span><span class="c1"># 修饰</span>
<span class="n">to_sort</span> <span class="o">=</span> <span class="p">[(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">item</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">a_list</span>

<span class="c1"># 排序</span>
<span class="n">to_sort</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

<span class="c1"># 反修饰:</span>
<span class="n">a_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">to_sort</span><span class="p">]</span>
</pre></div>


<p>第一行我们创建一个包含 tuples 的列表，按优先级顺序复制排序列，后面跟着完整的数据记录
第二行做通常的  Python 排序，非常快速和高效。
第三行我们去获取排好序的列表的最后一个数据。记住，最后一个数据就是完整的数据记录。 我们扔掉排序列，它们已经完成了它们的工作，现在没用了。
这是一个空间、复杂度和时间的权衡。更简单、更快，但是我们需要复制一份原始列表。</p>
<h2>按键值排序</h2>
<p>Python 2.4 为 <code>sort</code> 列表方法引入了一个可选参数，「key」， 用于指定一个单参数函数来返回列表中每个元素用于比较的键值。举例来说:</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">my_key</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">item</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">to_sort</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">my_key</span><span class="p">)</span>
</pre></div>


<p>函数 <code>my_key</code> 会在操作 <code>to_sort</code> 列表每一个项时都调用一次。</p>
<p>You can make your own key function, or use any existing one-argument function if applicable: 你可以实现自己的key函数，或者在可能的情况下使用已经存在的单参数函数:</p>
<ul>
<li><code>str.lower</code> 可以用于按忽略大小写的字母顺序排序。</li>
<li><code>len</code> 可以用于按项的长度排序 (字符串或容器)。</li>
<li><code>int</code> 或 <code>float</code> 可以用于对那些「数字型字符串」，比如 "2", "123", "35" 之类， 按实际数字大小排序。</li>
</ul>
<h2>生成器</h2>
<p>我们已经见过生成器表达式了。我们还可以定制我们自己的任意复杂的生成器， 就像定义函数一样:</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">my_range_generator</span><span class="p">(</span><span class="n">stop</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">value</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_range_generator</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">do_something</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>


<p><code>yield</code> 关键字把一个函数转变成一个生成器 (generator)。当我们调用一个生成器函数，  Python 并不是立即去运行代码，而是返回一个生成器对象，本质上它是一个迭代器； 它有一个 <code>next</code> 方法。 <code>for</code> 循环每次都会去调用迭代器的 <code>next</code> 方法， 直到 <code>StopIteration</code> 异常抛出。 你也可以显式抛出 <code>StopIteration</code> , 或者如上所示，在生成器代码运行结束时隐式抛出。</p>
<p>生成器可以简化序列/迭代器的处理，因为我们不需要去构建一个具体的列表； 只需要一次计算一个值。 生成器函数需要维护状态。</p>
<p>【译注：说到「需要维护状态」，我们必须首先搞清楚函数的「状态」。一般的函数，只要不使用全局变量，我们都认为它是「无状态的」，也就是说，任何时候，我们调用函数，传入相同的输入参数， 必能得到相同的输出结果。但生成器函数不是这样，它是「带状态的」，我们使用相同输入参数去调用， 每次会得到不同的结果。其结果取决于上一次调用的「状态」。因此它是带状态的，我们需要仔细维护这种状态，否则我们会得不到想要的结果】</p>
<p>这就是 <code>for</code> 循环的实际工作原理。Python 在 in 关键字后面寻找一个序列。如果它是一个简单的容器 （比如list、tuple、dictionaryset，或者用户定义的容器）， Python 会把容器转换成一个迭代器。 如果它已经是一个迭代器， Python 就直接使用它。</p>
<p>Python 重复调用迭代器的 <code>next</code> 方法，将返回值复制给循环计数器(本例中就是 <code>i</code> )， 然后执行循环体内的代码。这个动作周而复始，直到抛出 <code>StopIteration</code> 异常， 或者在代码中执行到 <code>break</code> 语句。</p>
<p><code>for</code> 循环可以有一个 <code>else</code> 子句，它会在迭代器运行完成后执行， 但不会在 <code>break</code> 语句之后执行。这种区别可以用来完成一些优雅的使用。 <code>else</code> 子句在 <code>for</code> 循环中并不常用，但它们可以派上用场。 有时 <code>else</code> 子句可以完美的表达你需要的逻辑。</p>
<p>举个例子，如果我们需要对一个序列中的项做条件检查，只要任意项的条件符合就通过:</p>
<div class="highlight"><pre><span></span>    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Condition not satisfied.&#39;</span><span class="p">)</span>
</pre></div>


<h2>生成器举例</h2>
<p>从一个 CSV reader (或一个 list 的项)中过滤空行:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">filter_rows</span><span class="p">(</span><span class="n">row_iterator</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">row_iterator</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">row</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">row</span>

<span class="n">data_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
<span class="n">irows</span> <span class="o">=</span> <span class="n">filter_rows</span><span class="p">(</span><span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">data_file</span><span class="p">))</span>
</pre></div>


<h2>从文本/数据文件中按行读取</h2>
<div class="highlight"><pre><span></span><span class="n">datafile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;datafile&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">datafile</span><span class="p">:</span>
    <span class="n">do_something</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
</pre></div>


<p>这样做是可以的，因为文件对象支持 <code>next</code> 方法，就像其它迭代器所做的那样: lists、tuples、字典(的键值)、生成器。</p>
<p>这里有一个警告: 因为缓存实现方法的区别，你不能混合使用 <code>.next</code> 和 <code>.read*</code> 方法， 除非你用的是  Python 2.5+。</p>
<h2>EAFP vs. LBYL</h2>
<p>It's easier to ask forgiveness than permission
EAFP: 获得宽恕比获得许可要容易</p>
<p>Look before you leap
LBYL: 三思而后行</p>
<p>一般来说 EAFP 更好，但不是任何时候。</p>
<ul>
<li>鸭子类型
如果一个东西走起来像鸭子，叫起来像鸭子，看起来像鸭子：它就是鸭子。 (鹅？反正看起来差不多。)</li>
<li>异常
如果一个对象必须是一个特定类型，使用强制转换。 如果 x 必须是一个字符串才能让代码工作，为什么不直接调用</li>
</ul>
<div class="highlight"><pre><span></span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>


<p>而不是去做尝试：</p>
<div class="highlight"><pre><span></span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>


<h2>EAFP风格的 try/except 举例</h2>
<p>你可以把容易发生异常的代码包裹进一个 <code>try/except</code> 代码块来捕获错误， 你可以最终会给出一个非常通用的解决方案，而不是试图预测每一种可能性。</p>
<div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>


<p>注意：一定要指定捕获的异常。永远不要使用裸 <code>except</code> 子句【译注：不带任何异常声明的 except， 如： except: pass 这样】。裸 <code>except</code> 子句会捕获你不希望捕获的异常， 让你的代码非常难以调试。</p>
<h2>导入</h2>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">module</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>


<p>你可能见过这种「通配符」形式的导入语句。你甚至可能喜欢这样做。 不要这样用。</p>
<p>【译注：以下一段是某个 Python 幽默段子的片段，背景是《星球大战》。
为了快速翻译及我认为不会太影响理解，我就不费心去查找和介绍背景资料了。 感兴趣的同学请自行去查看原文和相关背景。】</p>
<p>To adapt <a href="http://www. python.org/doc/humor/# python-vs-perl-according-to-yoda">a well-known exchange</a>:</p>
<blockquote>
<p>(Exterior Dagobah, jungle, swamp, and mist.)
卢克: from module import * 比显式 imports 要好吗？
犹达: 不，不是更好。更快、更容易，更妖媚。
卢克: 但是我如何知道显式的 imports 比通配符形式的更好？
犹达：从现在开始的六个月后你试图读自己的代码时就会知道。</p>
</blockquote>
<p>通配符导入来自  Python 的黑暗面。</p>
<p><strong>永远不要！</strong></p>
<p><code>from module import *</code> 通配符形式会导致命名空间污染。 你会在你的本地命名空间里得到你根本得到的东西。 你也许会发现导入的名字模糊了本地模块定义的名字。你可能无法辨认一个 具体的名字到底来自哪里。也许这样做方便快捷，但它不该存在于生产代码之中。</p>
<p>正义的呼声： <strong>不要使用通配符导入！</strong></p>
<p>更好的做法:</p>
<ul>
<li>通过模块引用名字(完整规格的标识符)</li>
<li>使用一个较短的名称导入一个较长名字的模块 (别名; 推荐)，</li>
<li>或者显式的仅仅导入你要用的名字。</li>
</ul>
<p>命名空间污染警告！
相反地,
通过模块引用名字(完整规格的标识符):</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">module</span>
<span class="n">module</span><span class="o">.</span><span class="n">name</span>
</pre></div>


<p>或者通过较短的名称导入较长名字的模块 (别名):</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">long_module_name</span> <span class="kn">as</span> <span class="nn">mod</span>
<span class="n">mod</span><span class="o">.</span><span class="n">name</span>
</pre></div>


<p>或者显式的仅仅导入你需要的名字:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">module</span> <span class="kn">import</span> <span class="n">name</span>
<span class="n">name</span>
</pre></div>


<p>注意交互环境下，当你需要编辑和「重载 (reload())」一个模块时，这种形式 不适合用于自身。</p>
<h2>模块和脚本</h2>
<p>想制作一个既是可导入的模块又是可执行的脚本:</p>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># script code here</span>
</pre></div>


<p>当模块被导入时，它的 <code>__name__</code> 属性被设置成模块的文件名，不含「.py」。 因此上面那段用 if 语句守护着的代码不会在导入时被执行。 当以脚本形式执行的时候， <code>__name__</code>属性会被设置称 <code>"__main__"</code>, 这段脚本代码 会 运行。</p>
<p>除了一些特殊情况，你不应该在最顶层放置任何重要可执行代码。 将代码放入函数、类、方法，或者用 <code>if __name__ == '__main__'</code> 守护起来。</p>
<h2>模块结构</h2>
<div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;module docstring(模块 docstring)&quot;&quot;&quot;</span>

<span class="c1"># imports(导入)</span>
<span class="c1"># constants(常量)</span>
<span class="c1"># exception classes(异常类)</span>
<span class="c1"># interface functions(接口函数)</span>
<span class="c1"># classes(类)</span>
<span class="c1"># internal functions &amp; classes(内部函数和类)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">main</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
</pre></div>


<p>模块应该拥有如上一样的代码结构.</p>
<h2>命令行处理</h2>
<p>Example: <a href="http://www.ch-linghu.me/article/idiomatic/cmdline.py">cmdline.py</a>:</p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env  python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module docstring.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">optpars</span>

<span class="k">def</span> <span class="nf">process_command_line</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a 2-tuple: (settings object, args list).</span>
<span class="sd">    `argv` is a list of arguments, or `None` for ``sys.argv[1:]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">argv</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># initialize the parser object:</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">optparse</span><span class="o">.</span><span class="n">OptionParser</span><span class="p">(</span>
        <span class="n">formatter</span><span class="o">=</span><span class="n">optparse</span><span class="o">.</span><span class="n">TitledHelpFormatter</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">78</span><span class="p">),</span>
        <span class="n">add_help_option</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

    <span class="c1"># define options here:</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_option</span><span class="p">(</span>      <span class="c1"># customized description; put --help last</span>
        <span class="s1">&#39;-h&#39;</span><span class="p">,</span> <span class="s1">&#39;--help&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;help&#39;</span><span class="p">,</span>
        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Show this help message and exit.&#39;</span><span class="p">)</span>

    <span class="n">settings</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

    <span class="c1"># check number of arguments, verify values, etc.:</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;program takes no command-line arguments; &#39;</span>
                <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; ignored.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,))</span>

    <span class="c1"># further process settings &amp; args if necessary</span>

    <span class="k">return</span> <span class="n">settings</span><span class="p">,</span> <span class="n">args</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">settings</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">process_command_line</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
    <span class="c1"># application code here, like:</span>
    <span class="c1"># run(settings, args)</span>
    <span class="k">return</span> <span class="mi">0</span>        <span class="c1"># success</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">main</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
</pre></div>


<h2>包</h2>
<div class="highlight"><pre><span></span><span class="n">package</span><span class="o">/</span>
    <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="n">module1</span><span class="o">.</span><span class="n">py</span>
    <span class="n">subpackage</span><span class="o">/</span>
        <span class="n">__init__</span><span class="o">.</span><span class="n">py</span>
        <span class="n">module2</span><span class="o">.</span><span class="n">py</span>
</pre></div>


<ul>
<li>用来组织你的项目.</li>
<li>减少加载路径的数量.</li>
<li>减少导入名字冲突.</li>
</ul>
<p>Example:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">package.module1</span>
<span class="kn">from</span> <span class="nn">package.subpackage</span> <span class="kn">import</span> <span class="n">module2</span>
<span class="kn">from</span> <span class="nn">package.subpackage.module2</span> <span class="kn">import</span> <span class="n">name</span>
</pre></div>


<p>在 Python 2.5中我们可以通过一个future import来实现绝对导入和相对导入:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span>
</pre></div>


<p>我自己还没有深入研究过这个特性，所以我们不会深入讨论它。</p>
<h2>简单好过复杂</h2>
<blockquote>
<p>调试的难度是你第一次写代码的难度的两倍。因此，如果你写了尽你可能聪明的代码， 你，从定义上说，没聪明到可以调试它。—Brian W. Kernighan, co-author of The C Programming Language and the "K" in "AWK"</p>
</blockquote>
<p>换句话说，保持你的程序简单！</p>
<h2>不要重新发明轮子</h2>
<p>在着手写任何代码之前，
➔ ➔ ➔ ➔</p>
<ul>
<li>检查  Python 标准库。</li>
<li>
<p>检查  Python 包索引(pypi) (乳酪店): 【译注，现在的 pypi 已经升级了，不再是乳酪店了，直接访问 http://pypi. python.org/ 即可 】</p>
<blockquote>
<p><a href="http://cheeseshop. python.org/pypi">http://cheeseshop. python.org/pypi</a></p>
</blockquote>
</li>
<li>
<p>搜索网络. Google 是你的朋友.</p>
</li>
</ul>
<h2>参考文献</h2>
<ul>
<li><a href="http://www.effbot.org/zone/ python-objects.htm">"python Objects", Fredrik Lundh</a></li>
<li><a href="http:// python.net/crew/mwh/hacks/objectthink.html">"How to think like a  pythonista", Mark Hammond</a></li>
<li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=4829">"python main() functions", Guido van Rossum</a></li>
<li><a href="http://jaynes.colorado.edu/ pythonIdioms.html">"python Idioms and Efficiency"</a></li>
<li><a href="http://www.cs.caltech.edu/courses/cs11/material/ python/misc/ python_idioms.html">"python track:  python idioms"</a></li>
<li><a href="http://shalabh.infogami.com/Be_ pythonic2">"Be  pythonic", Shalabh Chaturvedi</a></li>
<li><a href="http://dirtsimple.org/2004/12/ python-is-not-java.html">"python Is Not Java", Phillip J. Eby</a></li>
<li><a href="http://faassen.n--tree.net/blog/view/weblog/2005/08/06/0">"What is  pythonic?", Martijn Faassen</a></li>
<li><a href="http://wiki. python.org/moin/HowTo/Sorting">"Sorting Mini-HOWTO", Andrew Dalke</a></li>
<li><a href="http://www.gungfu.de/facts/wiki/Main/ pythonIdioms">"python Idioms"</a></li>
<li><a href="http://www. python.org/doc/faq/">"python FAQs"</a></li>
</ul>
    </article>

        <div class="tags">
            <p>tags: <a href="/tag/reformat.html">reformat</a> </p>
        </div>

<hr>
<div class="sharing">
</div>
    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="http://blog.breakwire.me/feeds/all.atom.xml" target="_blank">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="https://twitter.com/lsdvincent" target="_blank">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="https://instagram.com/lsdvincent/" target="_blank">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/lsdlab" target="_blank">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="https://medium.com/@breakwire" target="_blank">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-medium fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Copyright © 2014-2016 - Chen Jian -
    <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a>
</p>
<p class="copyright text-muted" style="margin-top: 0px;">
    Blog powered by <a href="http://getpelican.com" target="_blank">Pelican</a>, themed with <a href="https://github.com/gilsondev/pelican-clean-blog" target="_blank">Pelican Clean Blog, </a> which takes great advantage of <a href="http://python.org" target="_blank">Python</a>.
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="/theme/js/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="/theme/js/clean-blog.min.js"></script>

</body>

</html>